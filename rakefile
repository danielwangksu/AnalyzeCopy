require_relative "runner"
require_relative "formatter"
require_relative "formatter2"
require_relative "save_results_as_csv"
require_relative "hdiutil"


# example of the string returned: "Mac OS X 10.5.8 (9L31a)"
def obtain_system_version
  "%s %s (%s)" % (`sw_vers`.scan(/:\s+(.*?)$/m))
end


desc "Show overview of all tests"
task :tests do
  Runner.instance.tests.each do |t| 
    name = t.class::NAME
    info = t.installation_status
    puts("%-40s %s" % [name, info])
  end
end

desc "Show overview of all testees"
task :testees do
  Runner.instance.testees.each do |t| 
    name = t.class::NAME
    info = t.installation_status
    puts("%-40s %s" % [name, info])
  end
end



desc "list the ignored tests"
task :list_ignored do
  r = Runner.instance
  puts "--------- CAN RUN ALL TESTS? ---------"
  r.testees.each do |t| 
    name = t.class::NAME
    ary = t.ignore_tests || []
    s = ary.empty? ? "yes" : ("NOT " + ary.join(", "))
    puts("   %20s ... %s" % [name, s])
  end
end

desc "li is shorthand for list_ignored"
task :li => :list_ignored

desc "determine how many test dataset groups that are needed"
task :group do
  r = Runner.instance
  puts "-------------- groups_and_tests --------------"
  r.groups_and_tests.each do |groupname, testnames|
    s = "ALL"
    if testnames && testnames.size > 0
      s = "exclude " + testnames.join(", ")
    end
    puts "%20s ... %-s" % [groupname, s]
  end
  puts "-------------- testee_groups --------------"
  r.testees.each_with_index do |t, i|
    testeename = r.testee_names[i]
    groupname = r.testee_groups[i]
    puts "%20s ... %-s" % [testeename, groupname]
  end
end

task :g => :group


task :create_and_mount do
  create_and_mount_volume("AnalyzeCopySource")
  create_and_mount_volume("AnalyzeCopyDest")
end

desc "detach the diskimages"
task :unmount do
  hdiutil_unmount("AnalyzeCopySource")
  hdiutil_unmount("AnalyzeCopyDest")
end

desc "force detachment of the diskimages"
task :force_unmount do
  hdiutil_unmount_force("AnalyzeCopySource")
  hdiutil_unmount_force("AnalyzeCopyDest")
end

task :clean do
  FileUtils.rm_f("AnalyzeCopySource.sparseimage")
  FileUtils.rm_f("AnalyzeCopyDest.sparseimage")
end

task :cam => :create_and_mount
task :um => :unmount

task :run do
  src_dir = "/Volumes/AnalyzeCopySource"
  dest_dir = "/Volumes/AnalyzeCopyDest"

  r = Runner.instance

  # make sure the source and destination volumes are mounted
  r.check(src_dir)
  r.check(dest_dir)

  puts "=========== REMOVE OLD TEST RESULTS ==========="
  r.clean_results(dest_dir)

  puts "=========== GENERATE LOTS OF TEST DATA ==========="
  r.create(src_dir)

  puts "=========== COPY TEST DATA ==========="
  r.perform_copy(src_dir, dest_dir)
end

task :verify do
  src_dir = "/Volumes/AnalyzeCopySource"
  dest_dir = "/Volumes/AnalyzeCopyDest"

  r = Runner.instance

  # make sure the source and destination volumes are mounted
  r.check(src_dir)
  r.check(dest_dir)

  puts "=========== VERIFYING DATA ==========="
  r.perform_verify(src_dir, dest_dir)
end

desc "Generate an .csv file with the results"
task :csv do
  dest_dir = "/Volumes/AnalyzeCopyDest"

  r = Runner.instance
  r.check(dest_dir)
  
  
  ary_tests = []
  r.tests.each_with_index do |test, test_index|  
    name = test.class::NAME.dup
    ary_tests << {
      :name => name,
      :ident => name.match(/^\d+/).to_s,
      :prettyname => name.sub(/^\d+_/, ''),
      :is_installed => r.tests_installed[test_index]
    }
  end

  ary_testees = []
  r.testees.each_with_index do |testee, testee_index|  
    is_installed = r.testees_installed[testee_index]
    version = is_installed ? testee.version : "NOT INSTALLED"
    ary_testees << {
      :name => testee.class::NAME.dup,
      :is_installed => is_installed,
      :version => version
    }
  end
  
  c = CSVResults.new
  c.run(dest_dir, ary_tests, ary_testees)
  c.write("index.csv")
end

desc "Generate an index.html report"
task :html do
  dest_dir = "/Volumes/AnalyzeCopyDest"

  r = Runner.instance
  r.check(dest_dir)
  
  
  ary_tests = []
  r.tests.each_with_index do |test, test_index|  
    name = test.class::NAME.dup
    ary_tests << {
      :name => name,
      :ident => name.match(/^\d+/).to_s,
      :prettyname => name.sub(/^\d+_/, ''),
      :is_installed => r.tests_installed[test_index]
    }
  end

  ary_testees = []
  r.testees.each_with_index do |testee, testee_index|  
    is_installed = r.testees_installed[testee_index]
    version = is_installed ? testee.version : "NOT INSTALLED"
    ary_testees << {
      :name => testee.class::NAME.dup,
      :is_installed => is_installed,
      :version => version
    }
  end
  

  f = Formatter.new
  f.system_version = obtain_system_version
  f.run(dest_dir, ary_tests, ary_testees)
  f.write("index.html")

  `open index.html`
end

desc "Generate an index.html report"
task :html2 do
  dest_dir = "/Volumes/AnalyzeCopyDest"

  r = Runner.instance
  r.check(dest_dir)
  
  
  ary_tests = []
  r.tests.each_with_index do |test, test_index|  
    name = test.class::NAME.dup
    ary_tests << {
      :name => name,
      :ident => name.match(/^\d+/).to_s,
      :prettyname => name.sub(/^\d+_/, ''),
      :is_installed => r.tests_installed[test_index]
    }
  end


  f = Formatter2.new
  f.system_version = obtain_system_version
  f.run(ary_tests)
  f.write("index.html")

  `open index.html`
end

task :h => :html2

task :sudo do
  puts "this script must run as root"
  system("sudo true")
end

desc "Verify and generate Html"
task :vh_old => [:sudo, :verify, :html]

desc "Verify and generate CSV and them format as Html"
task :vh => [:sudo, :verify, :csv, :html2]


desc "Run all tests. You can ignore all the other commands. This is the primary way to run the tests."
task :default => [:sudo, :create_and_mount, :run, :verify, :csv, :html2]